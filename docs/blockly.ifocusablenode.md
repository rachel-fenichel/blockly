Project: /blockly/_project.yaml
Book: /blockly/_book.yaml

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [blockly](./blockly.md) &gt; [IFocusableNode](./blockly.ifocusablenode.md)

## IFocusableNode interface

Represents anything that can have input focus.

**Signature:**

```typescript
export interface IFocusableNode 
```

## Methods

|  Method | Description |
|  --- | --- |
|  [canBeFocused()](./blockly.ifocusablenode.canbefocused.md) | <p>Indicates whether this node allows focus. If this returns false then none of the other IFocusableNode methods will be called.</p><p>Note that special care must be taken if implementations of this function dynamically change their return value value over the lifetime of the node as certain environment conditions could affect the focusability of this node's DOM element (such as whether the element has a positive or zero tabindex). Also, changing from a true to a false value while the node holds focus will not immediately change the current focus of the node nor FocusManager's internal state, and thus may result in some of the node's functions being called later on when defocused (since it was previously considered focusable at the time of being focused).</p><p>Implementations should generally always return true here unless there are circumstances under which this node should be skipped for focus considerations. Examples may include being disabled, read-only, a purely visual decoration, or a node with no visual representation that must implement this interface (e.g. due to a parent interface extending it). Keep in mind accessibility best practices when determining whether a node should be focusable since even disabled and read-only elements are still often relevant to providing organizational context to users (particularly when using a screen reader).</p> |
|  [getFocusableElement()](./blockly.ifocusablenode.getfocusableelement.md) | <p>Returns the DOM element that can be explicitly requested to receive focus.</p><p>IMPORTANT: Please note that this element is expected to have a visual presence on the page as it will both be explicitly focused and have its style changed depending on its current focus state (i.e. blurred, actively focused, and passively focused). The element will have one of two styles attached (where no style indicates blurred/not focused): - blocklyActiveFocus - blocklyPassiveFocus</p><p>The returned element must also have a valid ID specified, and unique across the entire page. Failing to have a properly unique ID could result in trying to focus one node (such as via a mouse click) leading to another node with the same ID actually becoming focused by FocusManager. The returned element must also have a negative tabindex (since the focus manager itself will manage its tab index and a tab index must be present in order for the element to be focusable in the DOM).</p><p>The returned element must be visible if the node is ever focused via FocusManager.focusNode() or FocusManager.focusTree(). It's allowed for an element to be hidden until onNodeFocus() is called, or become hidden with a call to onNodeBlur().</p><p>It's expected the actual returned element will not change for the lifetime of the node (that is, its properties can change but a new element should never be returned).</p> |
|  [getFocusableTree()](./blockly.ifocusablenode.getfocusabletree.md) | Returns the closest parent tree of this node (in cases where a tree has distinct trees underneath it), which represents the tree to which this node belongs. |
|  [onNodeBlur()](./blockly.ifocusablenode.onnodeblur.md) | <p>Called when this node loses active focus. It may still have passive focus.</p><p>This has the same implementation restrictions as onNodeFocus().</p> |
|  [onNodeFocus()](./blockly.ifocusablenode.onnodefocus.md) | <p>Called when this node receives active focus.</p><p>Note that it's fine for implementations to change visibility modifiers, but they should avoid the following: - Creating or removing DOM elements (including via the renderer or drawer). - Affecting focus via DOM focus() calls or the FocusManager.</p> |

